[1mdiff --git a/src/server.rs b/src/server.rs[m
[1mindex 01b27aa..daa14fc 100644[m
[1m--- a/src/server.rs[m
[1m+++ b/src/server.rs[m
[36m@@ -14,6 +14,7 @@[m [muse axum::{[m
 use futures::stream;[m
 [m
 use serde::{Deserialize, Serialize};[m
[32m+[m[32muse serde_json::Value;[m
 use std::sync::Arc;[m
 [m
 use std::convert::Infallible;[m
[36m@@ -515,113 +516,213 @@[m [masync fn openai_completions([m
     Ok(Json(body).into_response())[m
 }[m
 [m
[31m-async fn responses([m
[31m-    State(state): State<SharedState>,[m
[31m-    Json(req): Json<serde_json::Value>,[m
[31m-) -> Result<Json<serde_json::Value>, AppError> {[m
[31m-    tracing::info!("Received v1/responses request");[m
[31m-[m
[31m-    let model_name = req[m
[31m-        .get("model")[m
[31m-        .and_then(|v| v.as_str())[m
[31m-        .unwrap_or("chorus")[m
[31m-        .to_string();[m
[31m-[m
[31m-    // Build prompt from messages | input | prompt[m
[31m-    let build_from_blocks = |blocks: &Vec<serde_json::Value>| -> String {[m
[31m-        let mut out = String::new();[m
[31m-        for b in blocks {[m
[31m-            if let Some(s) = b.as_str() {[m
[31m-                if !out.is_empty() {[m
[31m-                    out.push('\n');[m
[32m+[m[32mfn extract_text_value(value: &Value) -> Option<String> {[m
[32m+[m[32m    match value {[m
[32m+[m[32m        Value::Null => None,[m
[32m+[m[32m        Value::Bool(b) => Some(b.to_string()),[m
[32m+[m[32m        Value::Number(n) => Some(n.to_string()),[m
[32m+[m[32m        Value::String(s) => {[m
[32m+[m[32m            let trimmed = s.trim();[m
[32m+[m[32m            if trimmed.is_empty() {[m
[32m+[m[32m                None[m
[32m+[m[32m            } else {[m
[32m+[m[32m                Some(trimmed.to_string())[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        Value::Array(items) => {[m
[32m+[m[32m            let mut parts = Vec::new();[m
[32m+[m[32m            for item in items {[m
[32m+[m[32m                if let Some(text) = extract_text_value(item) {[m
[32m+[m[32m                    if !text.is_empty() {[m
[32m+[m[32m                        parts.push(text);[m
[32m+[m[32m                    }[m
                 }[m
[31m-                out.push_str(s);[m
[31m-                continue;[m
             }[m
[31m-            if let Some(t) = b.get("text").and_then(|t| t.as_str()) {[m
[31m-                if !out.is_empty() {[m
[31m-                    out.push('\n');[m
[32m+[m[32m            if parts.is_empty() {[m
[32m+[m[32m                None[m
[32m+[m[32m            } else {[m
[32m+[m[32m                Some(parts.join("\n"))[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        Value::Object(map) => {[m
[32m+[m[32m            for key in ["text", "input_text", "value", "output_text"] {[m
[32m+[m[32m                if let Some(Value::String(s)) = map.get(key) {[m
[32m+[m[32m                    let trimmed = s.trim();[m
[32m+[m[32m                    if !trimmed.is_empty() {[m
[32m+[m[32m                        return Some(trimmed.to_string());[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            if let Some(content) = map.get("content") {[m
[32m+[m[32m                if let Some(text) = extract_text_value(content) {[m
[32m+[m[32m                    if !text.is_empty() {[m
[32m+[m[32m                        return Some(text);[m
[32m+[m[32m                    }[m
                 }[m
[31m-                out.push_str(t);[m
[31m-                continue;[m
             }[m
[31m-            if let Some(t) = b.get("content").and_then(|c| c.as_str()) {[m
[31m-                if !out.is_empty() {[m
[31m-                    out.push('\n');[m
[32m+[m[32m            if let Some(parts) = map.get("parts") {[m
[32m+[m[32m                if let Some(text) = extract_text_value(parts) {[m
[32m+[m[32m                    if !text.is_empty() {[m
[32m+[m[32m                        return Some(text);[m
[32m+[m[32m                    }[m
                 }[m
[31m-                out.push_str(t);[m
[31m-                continue;[m
             }[m
[31m-            if let Some(arr) = b.get("content").and_then(|c| c.as_array()) {[m
[31m-                let part = arr[m
[31m-                    .iter()[m
[31m-                    .filter_map(|p| {[m
[31m-                        p.get("text")[m
[31m-                            .and_then(|t| t.as_str())[m
[31m-                            .map(|s| s.to_string())[m
[31m-                    })[m
[31m-                    .collect::<Vec<_>>()[m
[31m-                    .join("\n");[m
[31m-                if !part.is_empty() {[m
[31m-                    if !out.is_empty() {[m
[31m-                        out.push('\n');[m
[32m+[m[32m            if let Some(messages) = map.get("messages") {[m
[32m+[m[32m                if let Some(text) = extract_text_value(messages) {[m
[32m+[m[32m                    if !text.is_empty() {[m
[32m+[m[32m                        return Some(text);[m
                     }[m
[31m-                    out.push_str(&part);[m
                 }[m
             }[m
[32m+[m[32m            None[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfn extract_message_text(value: &Value) -> Option<String> {[m
[32m+[m[32m    if let Value::Object(map) = value {[m
[32m+[m[32m        let role = match map.get("role").and_then(|v| v.as_str()) {[m
[32m+[m[32m            Some(role) => role,[m
[32m+[m[32m            None => return None,[m
[32m+[m[32m        };[m
[32m+[m[32m        if let Some(content) = map.get("content") {[m
[32m+[m[32m            if let Some(text) = extract_text_value(content) {[m
[32m+[m[32m                if text.is_empty() {[m
[32m+[m[32m                    return None;[m
[32m+[m[32m                }[m
[32m+[m[32m                return Some(format!("{}: {}", role, text));[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
[32m+[m[32m        if let Some(Value::String(text)) = map.get("text") {[m
[32m+[m[32m            let trimmed = text.trim();[m
[32m+[m[32m            if trimmed.is_empty() {[m
[32m+[m[32m                return None;[m
[32m+[m[32m            }[m
[32m+[m[32m            return Some(format!("{}: {}", role, trimmed));[m
[32m+[m[32m        }[m
[32m+[m[32m    }[m
[32m+[m[32m    None[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfn extract_prompt_from_responses_body(payload: &Value) -> Option<String> {[m
[32m+[m[32m    let mut segments: Vec<String> = Vec::new();[m
[32m+[m
[32m+[m[32m    if let Some(Value::String(instr)) = payload.get("instructions") {[m
[32m+[m[32m        let trimmed = instr.trim();[m
[32m+[m[32m        if !trimmed.is_empty() {[m
[32m+[m[32m            segments.push(format!("system: {}", trimmed));[m
         }[m
[31m-        out[m
[31m-    };[m
[31m-[m
[31m-    let prompt = if let Some(messages) = req.get("messages").and_then(|v| v.as_array()) {[m
[31m-        let mut parts = Vec::new();[m
[31m-        for m in messages {[m
[31m-            let role = m.get("role").and_then(|r| r.as_str()).unwrap_or("user");[m
[31m-            if let Some(s) = m.get("content").and_then(|c| c.as_str()) {[m
[31m-                parts.push(format!("{}: {}", role, s));[m
[31m-            } else if let Some(arr) = m.get("content").and_then(|c| c.as_array()) {[m
[31m-                let text = build_from_blocks(arr);[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if let Some(Value::Array(messages)) = payload.get("messages") {[m
[32m+[m[32m        for msg in messages {[m
[32m+[m[32m            if let Some(text) = extract_message_text(msg) {[m
[32m+[m[32m                segments.push(text);[m
[32m+[m[32m            } else if let Some(text) = extract_text_value(msg) {[m
                 if !text.is_empty() {[m
[31m-                    parts.push(format!("{}: {}", role, text));[m
[32m+[m[32m                    segments.push(text);[m
                 }[m
             }[m
         }[m
[31m-        parts.join("\n")[m
[31m-    } else if let Some(input) = req.get("input") {[m
[31m-        if let Some(s) = input.as_str() {[m
[31m-            s.to_string()[m
[31m-        } else if let Some(arr) = input.as_array() {[m
[31m-            build_from_blocks(arr)[m
[31m-        } else {[m
[31m-            String::new()[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    if let Some(input) = payload.get("input") {[m
[32m+[m[32m        match input {[m
[32m+[m[32m            Value::String(s) => {[m
[32m+[m[32m                let trimmed = s.trim();[m
[32m+[m[32m                if !trimmed.is_empty() {[m
[32m+[m[32m                    segments.push(trimmed.to_string());[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            Value::Array(items) => {[m
[32m+[m[32m                for item in items {[m
[32m+[m[32m                    if let Some(text) = extract_message_text(item) {[m
[32m+[m[32m                        segments.push(text);[m
[32m+[m[32m                    } else if let Some(text) = extract_text_value(item) {[m
[32m+[m[32m                        if !text.is_empty() {[m
[32m+[m[32m                            segments.push(text);[m
[32m+[m[32m                        }[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            Value::Object(_) => {[m
[32m+[m[32m                if let Some(text) = extract_message_text(input) {[m
[32m+[m[32m                    segments.push(text);[m
[32m+[m[32m                } else if let Some(text) = extract_text_value(input) {[m
[32m+[m[32m                    if !text.is_empty() {[m
[32m+[m[32m                        segments.push(text);[m
[32m+[m[32m                    }[m
[32m+[m[32m                }[m
[32m+[m[32m            }[m
[32m+[m[32m            _ => {}[m
         }[m
[31m-    } else if let Some(s) = req.get("prompt").and_then(|v| v.as_str()) {[m
[31m-        s.to_string()[m
[31m-    } else {[m
[31m-        String::new()[m
[31m-    };[m
[32m+[m[32m    }[m
 [m
[31m-    if prompt.trim().is_empty() {[m
[31m-        return Err(AppError(anyhow::anyhow!([m
[31m-            "invalid request: missing input/messages/prompt"[m
[31m-        )));[m
[32m+[m[32m    for key in ["prompt", "input_text"] {[m
[32m+[m[32m        if let Some(Value::String(s)) = payload.get(key) {[m
[32m+[m[32m            let trimmed = s.trim();[m
[32m+[m[32m            if !trimmed.is_empty() {[m
[32m+[m[32m                segments.push(trimmed.to_string());[m
[32m+[m[32m            }[m
[32m+[m[32m        }[m
     }[m
 [m
[32m+[m[32m    if segments.is_empty() {[m
[32m+[m[32m        None[m
[32m+[m[32m    } else {[m
[32m+[m[32m        Some(segments.join("\n"))[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32masync fn responses([m
[32m+[m[32m    State(state): State<SharedState>,[m
[32m+[m[32m    Json(req): Json<Value>,[m
[32m+[m[32m) -> Result<Response, AppError> {[m
[32m+[m[32m    let model_name = req[m
[32m+[m[32m        .get("model")[m
[32m+[m[32m        .and_then(|v| v.as_str())[m
[32m+[m[32m        .unwrap_or("chorus")[m
[32m+[m[32m        .to_string();[m
[32m+[m
[32m+[m[32m    let stream_requested = matches!([m
[32m+[m[32m        req.get("stream"),[m
[32m+[m[32m        Some(Value::Bool(true)) | Some(Value::Object(_))[m
[32m+[m[32m    );[m
[32m+[m
     let include_workflow_details = req[m
         .get("include_workflow")[m
         .and_then(|v| v.as_bool())[m
         .unwrap_or(false);[m
 [m
[31m-    let (response_text, workflow_details) = if include_workflow_details {[m
[31m-        let result = state[m
[31m-            .workflow_engine[m
[31m-            .process_with_details(prompt.clone())[m
[31m-            .await?;[m
[31m-        (result.final_response, Some(result.execution_details))[m
[31m-    } else {[m
[31m-        let response = state.workflow_engine.process(prompt).await?;[m
[31m-        (response, None)[m
[31m-    };[m
[32m+[m[32m    tracing::info!([m
[32m+[m[32m        "Received v1/responses request for model {}, stream: {}, include_workflow: {}",[m
[32m+[m[32m        model_name.as_str(),[m
[32m+[m[32m        stream_requested,[m
[32m+[m[32m        include_workflow_details[m
[32m+[m[32m    );[m
[32m+[m
[32m+[m[32m    let prompt = extract_prompt_from_responses_body(&req).ok_or_else(|| {[m
[32m+[m[32m        AppError(anyhow::anyhow!([m
[32m+[m[32m            "invalid request: missing input/messages/prompt/instructions"[m
[32m+[m[32m        ))[m
[32m+[m[32m    })?;[m
[32m+[m
[32m+[m[32m    let prompt_len = prompt.len();[m
[32m+[m
[32m+[m[32m    if stream_requested {[m
[32m+[m[32m        tracing::warn!([m
[32m+[m[32m            "Responses stream requested but streaming is not yet implemented; returning single response payload"[m
[32m+[m[32m        );[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    let (response_text, workflow_details) =[m
[32m+[m[32m        execute_workflow(&state, prompt, include_workflow_details).await?;[m
[32m+[m
[32m+[m[32m    tracing::debug!([m
[32m+[m[32m        "Generated responses payload (prompt {} bytes, response {} bytes)",[m
[32m+[m[32m        prompt_len,[m
[32m+[m[32m        response_text.len()[m
[32m+[m[32m    );[m
 [m
     let now = chrono::Utc::now();[m
     let resp = serde_json::json!({[m
[36m@@ -642,7 +743,7 @@[m [masync fn responses([m
         "workflow": workflow_details,[m
     });[m
 [m
[31m-    Ok(Json(resp))[m
[32m+[m[32m    Ok(Json(resp).into_response())[m
 }[m
 [m
 async fn list_models_openai(State(state): State<SharedState>) -> impl IntoResponse {[m
[36m@@ -687,6 +788,80 @@[m [masync fn list_models(State(state): State<SharedState>) -> impl IntoResponse {[m
     }))[m
 }[m
 [m
[32m+[m[32m#[cfg(test)][m
[32m+[m[32mmod responses_tests {[m
[32m+[m[32m    use super::extract_prompt_from_responses_body;[m
[32m+[m[32m    use serde_json::json;[m
[32m+[m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn extract_prompt_prefers_instructions_and_input() {[m
[32m+[m[32m        let payload = json!({[m
[32m+[m[32m            "instructions": "Be helpful",[m
[32m+[m[32m            "input": "Say hello"[m
[32m+[m[32m        });[m
[32m+[m[32m        assert_eq!([m
[32m+[m[32m            extract_prompt_from_responses_body(&payload).unwrap(),[m
[32m+[m[32m            "system: Be helpful\nSay hello"[m
[32m+[m[32m        );[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn extract_prompt_handles_message_arrays() {[m
[32m+[m[32m        let payload = json!({[m
[32m+[m[32m            "input": [[m
[32m+[m[32m                {[m
[32m+[m[32m                    "role": "user",[m
[32m+[m[32m                    "content": [[m
[32m+[m[32m                        {"type": "text", "text": "Hi there"}[m
[32m+[m[32m                    ][m
[32m+[m[32m                },[m
[32m+[m[32m                {[m
[32m+[m[32m                    "role": "assistant",[m
[32m+[m[32m                    "content": [[m
[32m+[m[32m                        {"type": "text", "text": "Hello!"}[m
[32m+[m[32m                    ][m
[32m+[m[32m                }[m
[32m+[m[32m            ][m
[32m+[m[32m        });[m
[32m+[m[32m        assert_eq!([m
[32m+[m[32m            extract_prompt_from_responses_body(&payload).unwrap(),[m
[32m+[m[32m            "user: Hi there\nassistant: Hello!"[m
[32m+[m[32m        );[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn extract_prompt_handles_messages_field_with_string_content() {[m
[32m+[m[32m        let payload = json!({[m
[32m+[m[32m            "messages": [[m
[32m+[m[32m                {"role": "user", "content": "ping"}[m
[32m+[m[32m            ][m
[32m+[m[32m        });[m
[32m+[m[32m        assert_eq!([m
[32m+[m[32m            extract_prompt_from_responses_body(&payload).unwrap(),[m
[32m+[m[32m            "user: ping"[m
[32m+[m[32m        );[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn extract_prompt_handles_text_blocks() {[m
[32m+[m[32m        let payload = json!({[m
[32m+[m[32m            "input": [[m
[32m+[m[32m                {"type": "text", "text": "First"},[m
[32m+[m[32m                {"type": "input_text", "text": "Second"}[m
[32m+[m[32m            ][m
[32m+[m[32m        });[m
[32m+[m[32m        assert_eq!([m
[32m+[m[32m            extract_prompt_from_responses_body(&payload).unwrap(),[m
[32m+[m[32m            "First\nSecond"[m
[32m+[m[32m        );[m
[32m+[m[32m    }[m
[32m+[m
[32m+[m[32m    #[test][m
[32m+[m[32m    fn extract_prompt_returns_none_when_empty() {[m
[32m+[m[32m        assert!(extract_prompt_from_responses_body(&json!({})).is_none());[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
 // ÈîôËØØÂ§ÑÁêÜ[m
 pub struct AppError(anyhow::Error);[m
 [m
